//********************************Variables para Configuración AccessPoint*********************
#include <WiFi.h>
const char* ssid     = "ESP32-Access-Point";
const char* password = "123456789";
WiFiServer server(80);
String header;

#include <Servo.h>
Servo myservo;
const short vel=50;

//Entradas
#define PE1 digitalRead(pe1)
#define PE2 digitalRead(pe2)
//#define CanalCamara
//#define ObsAdel
//#define ObsAtr
//#define ObsDer
//#define ObsIzq

//Salidas
#define MotD1  3            //Terminal 1 de MotorDerecho
#define MotD2  21           //Terminal 2 de MotorDerecho
#define MotI1  19           //Terminal 1 de MotorIzquierdo
#define MotI2  18           //Termianl 2 de MotorIzquierdo

// varaibles globales
short obs;                    //Obstaculos
short objP;                   //Posición de la pelota
boolean limC = false;       //Detección de límite de cancha
boolean Nav = false;        //Bandera de Navegacion
boolean evObs = false;      //Bandera de Evación de obstáculos
short i;                    //Varaible Auxiliar

// DECLARACION DE VARIABLES PARA PINES
const int pe1 = 23;
const int pe2 = 5;
const int pintrigger = 22;
const int pinled = 13;
 
// VARIABLES PARA CALCULOS
unsigned int distancia1, distancia2;

void setup() {
  // put your setup code here, to run once:
  // Entradas
  //Salidas
  pinMode(MotD1,OUTPUT);
  pinMode(MotD2,OUTPUT);
  pinMode(MotI1,OUTPUT);
  pinMode(MotI2,OUTPUT);
  
  //Serial.begin(115200);
  accessPointInit();

  // PREPARAR LA COMUNICACION SERIAL
  Serial.begin(9600);
  // CONFIGURAR PINES DE ENTRADA Y SALIDA
  pinMode(pe1, INPUT);
  pinMode(pe2, INPUT);
  pinMode(pintrigger, OUTPUT);
  pinMode(pinled, OUTPUT);

  myservo.attach(9);
}

void loop() {
  // put your main code here, to run repeatedly:
  
  //Modo Búsqueda
  Busqueda:
    Nav = false;                //bandera navegacion apagada
    goto lecSens;               //leer sensores
    if(objP == 3){              //si no se detectan pelotas
      for(i=50;i>=0;i+=50){     //comportamiento giro en espiral
        goto giroIzq;           //girar izquierda
        delay(i);               //para controlar giro
        goto adelante;           //avanzar
        delay(i);               //para controlar avance
        goto lecSens;           //leer sensores
      }
    }
    else{                       //si se detectan pelotas
      goto detener;             //detener avance
      Nav = true;               //bandera de navegacion activa
      goto Navegacion;          //Modo Navegacion
    }
    

  //Módo navegación
  Navegacion:
    if(objP == 1){          //Pelota a la derecha
      goto giroDer;         //girar derecha
      goto lecSens;         //leer sensores     
    }
    if(objP == 2){          //Pelota a la izquierda
      goto giroIzq;         //girar izquierda
      goto lecSens;         //leer sensores 
    }
    if(objP == 0){          //Pelota centrada
      goto lecSens;         //leer sensores
      goto adelante;        //Avanzar hacia adelante
    }

  //Modo Obstáculos
  Obstaculos:
    evObs = true;         //bandera de evacion de obstaculos activa
    goto detener;         //Detener motores
    delay(250);           //Esperar pequeño tiempo, evita cambio de polaridad brusca en motores
    if(obs == 1){         //Obstáculo a la derecha
      goto giroIzq;       //girar izquierda
      goto lecSens;       //leer sensores
      return;
    }
    if(obs == 2){         //Obstáculo a la izquierda
      goto giroDer;       //girar derecha
      goto lecSens;       //leer sensores
      return;
    }
    if(obs == 3){         //Obstáculo al frente
      goto giroDer;       //girar derecha
      goto lecSens;       //leer sensores
      return;
    }
    if(obs == 4){         //Obstáculo atrás
      goto giroDer;       //girar derecha
      goto lecSens;       //leer sensores
      return;
    }
    if(limC){             //Detección del límite de cancha
      goto lecSens;
      goto atras;         //Ir hacia atras
      delay(1000);        //Control de retroceso
      goto lecSens;       //leer sensores
      goto giroIzq;       //Girar izquierda
      delay(1000);        //control de giro Izquierdo
      goto lecSens;       //leer sensores
      return;
    } 

  lecSens:
    //Sección para asignar valores de los sensores y cuantizarlos
    aspas();
    visionPelotas();                                                //Busca centro de pelota, 0-centro,1-derecha,2-izquierda, 3-sin objetivo
    lecObs();
    if( Nav && (limC || obs ==3)){                                  //Si se encuentra un obstáculo enfrente, o se determina el límite de cancha mientras navega
      goto Obstaculos;
    }
    if( evObs && (limC || obs != 0)){                               //Si se encuentra evadiendo Obtáculos
      goto Obstaculos;
    }
    if(!limC && obs == 0){
      evObs == false;                                               //Bandera de evación de obstáculos desactivada
    }
    if(objP == 3){                                                  //Si no se detectan pelotas
      goto Busqueda;
    }
    return;

//Estados de movimiento 
  giroDer:
    digitalWrite(MotI1,HIGH);
    digitalWrite(MotI2,LOW);
    digitalWrite(MotD1,LOW);
    digitalWrite(MotD2,HIGH);
    return;
  
  giroIzq:
    digitalWrite(MotI1,LOW);
    digitalWrite(MotI2,HIGH); 
    digitalWrite(MotD1,HIGH);   
    digitalWrite(MotD2,LOW);
    
    return;
    
  adelante:
    digitalWrite(MotI1,HIGH);
    digitalWrite(MotI2,LOW); 
    digitalWrite(MotD1,HIGH);   
    digitalWrite(MotD2,LOW);
    return;
    
  atras:
    digitalWrite(MotI1,LOW);
    digitalWrite(MotI2,HIGH); 
    digitalWrite(MotD1,LOW);   
    digitalWrite(MotD2,HIGH);
    return;
    
  detener:
    digitalWrite(MotI1,LOW);
    digitalWrite(MotI2,LOW); 
    digitalWrite(MotD1,LOW);   
    digitalWrite(MotD2,LOW);
    return;
    

}

void accessPointInit(){
  WiFi.softAP(ssid, password);
  Serial.print("AccessPoint IP address: ");
  Serial.println(WiFi.softAPIP());
  server.begin();
}

int visionPelotas()
{
int ball;
WiFiClient client = server.available();     // Listen for incoming clients

  if (client) {                             // If a new client connects,
    Serial.println("New Client.");          // print a message out in the serial port
    String currentLine = "";                // make a String to hold incoming data from the client
    while (client.connected()) {            // loop while the client's connected
      if (client.available()) {             // if there's bytes to read from the client,
        char c = client.read();             // read a byte, then
        header += c;
        if (c == '\n') {                    // if the byte is a newline character
          // if the current line is blank, you got two newline characters in a row.
          // that's the end of the client HTTP request, so send a response:
          if (currentLine.length() == 0) {
            // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
            // and a content-type so the client knows what's coming, then a blank line:
            client.println("HTTP/1.1 200 OK");
            client.println("Content-type:text/html");
            client.println("Connection: close");
            client.println();
     
            if (header.indexOf("right") >= 0){ 
              Serial.println("Pelota a la derecha");
              ball=1;
            }
            if (header.indexOf("left") >= 0){ 
              Serial.println("Pelota a la izquierda");
              ball=2;
            }
            if (header.indexOf("null") >= 0) {
              Serial.println("NO se detecta pelota");
              ball=3;
            }
            if (header.indexOf("center") >= 0){
              Serial.println("Pelota en el centro");
              ball=0;
            }
            // The HTTP response ends with another blank line
            client.println();
            // Break out of the while loop
            break;
          } else { // if you got a newline, then clear currentLine
            currentLine = "";
          }
        } else if (c != '\r') {  // if you got anything else but a carriage return character,
          currentLine += c;      // add it to the end of the currentLine
        }
      }
    }
    // Clear the header variable
    header = "";
    // Close the connection
    client.stop();
    Serial.println("Client disconnected.");
    Serial.println("");
  }
  return ball;
} 

void lecObs() {
  // ENVIAR PULSO DE DISPARO EN EL PIN "TRIGGER"
  digitalWrite(pintrigger, LOW);
  delayMicroseconds(2);
  digitalWrite(pintrigger, HIGH);
  // EL PULSO DURA AL MENOS 10 uS EN ESTADO ALTO
  delayMicroseconds(10);
  digitalWrite(pintrigger, LOW);

unsigned int y1 = 0;
unsigned int y2 = 0;
unsigned int y3 = 0;
unsigned int y4 = 0;


  b00:
  if(PE1 == LOW && PE2 == LOW){
    delayMicroseconds(1);
    goto b00;
  }

  bi:
    if(PE1 == HIGH){
      y1++;
    }
    if(PE2 == HIGH){
      y2++;
    }
    //Descomentar para usar cuatro sensores
    /*if(PE3 == HIGH){
      y3++;
    }
    if(PE4 == HIGH){
      y4++;
    }*/

    if(PE1 == LOW && PE2 == LOW){
    //Descomentar para usar cuatro sensores
    //if(PE1 == LOW && PE2 == LOW && PE3 == LOW && PE4 == LOW){ 
      goto bf;
    }
  
  delayMicroseconds(1);
  goto bi;
  bf:

  //Por calibraciÃ³n, 20 fue el mejor valor, al menos de manera preliminar... 
  distancia1 = y1 / 20;
  distancia2 = y2 / 20; 
 
  //Serial
  Serial.print(distancia1);
  Serial.print(" --cm[1] ");
  Serial.print(distancia2);
  Serial.println(" --cm[2] ");
  delay(200);
 
}

void aspas(){
  myservo.write(vel);
}
